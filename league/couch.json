{
   "_id": "_design/league",
   "_rev": "72-0f9a9b749966948eaef857979b37079e",
   "filters": {
       "ranked_games": "function(doc, req) {  return doc.type === 'game' && doc.players.home.length && doc.players.visitors.length && doc.ranked;};",
       "unranked_games": "function(doc, req) {  return doc.type === 'game' && doc.players.home.length && doc.players.visitors.length && !doc.ranked;};"
   },
   "lib": {
       "mustache": "var Mustache = function() {var Renderer = function() {};Renderer.prototype = {otag: '{{',ctag: '}}',pragmas: {},buffer: [],pragmas_implemented: {'IMPLICIT-ITERATOR': true},context: {},render: function(template, context, partials, in_recursion) {            if(!in_recursion) {        this.context = context;        this.buffer = [];       }            if(!this.includes('', template)) {        if(in_recursion) {          return template;        } else {          this.send(template);          return;        }      }      template = this.render_pragmas(template);      var html = this.render_section(template, context, partials);      if(in_recursion) {        return this.render_tags(html, context, partials, in_recursion);      }      this.render_tags(html, context, partials, in_recursion);    },/*      Sends parsed lines    */    send: function(line) {      if(line != '') {        this.buffer.push(line);      }    },/*      Looks for %PRAGMAS    */    render_pragmas: function(template) {      if(!this.includes('%', template)) {        return template;      }      var that = this;      var regex = new RegExp(this.otag + '%([\\w-]+) ?([\\w]+=[\\w]+)?' +            this.ctag);      return template.replace(regex, function(match, pragma, options) {        if(!that.pragmas_implemented[pragma]) {          throw({message:             'This implementation of mustache doesnt understand the ' +            pragma + ' pragma'});        }        that.pragmas[pragma] = {};        if(options) {          var opts = options.split('=');          that.pragmas[pragma][opts[0]] = opts[1];        }        return '';      });    },/*      Tries to find a partial in the curent scope and render it    */    render_partial: function(name, context, partials) {      name = this.trim(name);      if(!partials || partials[name] === undefined) {        throw({message: 'unknown_partial ' + name + ''});      }      if(typeof(context[name]) != 'object') {        return this.render(partials[name], context, partials, true);      }      return this.render(partials[name], context[name], partials, true);    },/*      Renders inverted (^) and normal (#) sections    */    render_section: function(template, context, partials) {      if(!this.includes('#', template) && !this.includes('^', template)) {        return template;      }      var that = this;      var regex = new RegExp(this.otag + '(\\^|\\#)\\s*(.+)\\s*' + this.ctag +              '\n*([\\s\\S]+?)' + this.otag + '\\/\\s*\\2\\s*' + this.ctag +              '\\s*', 'mg');      return template.replace(regex, function(match, type, name, content) {        var value = that.find(name, context);          if(!value || that.is_array(value) && value.length === 0) {            return that.render(content, context, partials, true);          } else {            return '';          }            return that.map(value, function(row) {              return that.render(content, that.create_context(row),                partials, true);            }).join('');            return that.render(content, that.create_context(value),              partials, true);          } else if(typeof value === 'function') {            return value.call(context, content, function(text) {              return that.render(text, context, partials, true);            });            return that.render(content, context, partials, true);          } else {            return '';          }        }      });    },/*      Replace {{foo}} and friends with values from our view    */    render_tags: function(template, context, partials, in_recursion) {      var that = this;      var new_regex = function() {        return new RegExp(that.otag + '(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?' +          that.ctag + '+', 'g');      };      var regex = new_regex();      var tag_replace_callback = function(match, operator, name) {        switch(operator) {          return '';          that.set_delimiters(name);          regex = new_regex();          return '';          return that.render_partial(name, context, partials);          return that.find(name, context);          return that.escape(that.find(name, context));        }      };      var lines = template.split('\n');      for(var i = 0; i < lines.length; i++) {        lines[i] = lines[i].replace(regex, tag_replace_callback, this);        if(!in_recursion) {          this.send(lines[i]);        }      }      if(in_recursion) {        return lines.join('\n');      }    },set_delimiters: function(delimiters) {      var dels = delimiters.split(' ');      this.otag = this.escape_regex(dels[0]);      this.ctag = this.escape_regex(dels[1]);    },escape_regex: function(text) {      if(!arguments.callee.sRE) {        var specials = [          '/', '.', '*', '+', '?', '|',          '(', ')', '[', ']', '{', '}', '\\'        ];        arguments.callee.sRE = new RegExp(          '(\\' + specials.join('|\\') + ')', 'g'        );      }      return text.replace(arguments.callee.sRE, '\\$1');    },*      find `name` in current `context`. That is find me a value      from the view object    */    find: function(name, context) {      name = this.trim(name);      function is_kinda_truthy(bool) {        return bool === false || bool === 0 || bool;      }      var value;      if(is_kinda_truthy(context[name])) {        value = context[name];      } else if(is_kinda_truthy(this.context[name])) {        value = this.context[name];      }      if(typeof value === 'function') {        return value.apply(context);      }      if(value !== undefined) {        return value;      }      return '';    },/* includes tag */    includes: function(needle, haystack) {      return haystack.indexOf(this.otag + needle) != -1;    },    /*      Does away with nasty characters    */    escape: function(s) {      s = String(s === null ? '' : s);      return s.replace(/&(?!\\w+;)|[\"'<>\\]/g, function(s) {        switch(s) {     case '&': return '&amp;';        case '\\': return '\\\\';        case '\"': return '&quot;';    case '\\'': return '&#39;';        case '<': return '&lt;';        case '>': return '&gt;';           default: return s;        }      });    },create_context: function(_context) {      if(this.is_object(_context)) {        return _context;      } else {        var iterator = '.';        if(this.pragmas['IMPLICIT-ITERATOR']) {          iterator = this.pragmas['IMPLICIT-ITERATOR'].iterator;        }        var ctx = {};        ctx[iterator] = _context;        return ctx;      }    },    is_object: function(a) {      return a && typeof a == 'object';    },    is_array: function(a) {      return Object.prototype.toString.call(a) === '[object Array]';    },    /*      Gets rid of leading and trailing whitespace    */    trim: function(s) {      return s.replace(/^\\s*|\\s*$/g, '');    },/*      Why, why, why? Because IE. Cry, cry cry.    */    map: function(array, fn) {      if (typeof array.map == 'function') {        return array.map(fn);      } else {        var r = [];        var l = array.length;        for(var i = 0; i < l; i++) {          r.push(fn(array[i]));        }        return r;      }    }  };  return({    name: 'mustache.js',    version: '0.3.1-dev',    /*      Turns a template and view into HTML    */    to_html: function(template, view, partials, send_fun) {      var renderer = new Renderer();      if(send_fun) {        renderer.send = send_fun;      }      renderer.render(template, view, partials);      if(!send_fun) {        return renderer.buffer.join('\\n');      }    }  });}();exports.name = Mustache.name;exports.version = Mustache.version;exports.to_html = function() {return Mustache.to_html.apply(this, arguments);};"
   },
   "lists": {
       "feed": "function(head, req) {  start({'headers': {'content-type': 'text/html'}});  var mustache = require('lib/mustache'),      template = this.templates['feed.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    feeds: []  };  for (var key in locales) {    data['locales.' + key] = locales[key];  }    var format2digits = function(d) {    return (d > 9 ? ' : '0') + d;  };    var formatTime = function(t) {    var d = new Date(t);    return [format2digits(d.getHours()), format2digits(d.getMinutes())].join(':');  }    var formatTimespan = function(t1, t2) {    var d = new Date(t2 - t1);    return format2digits(d.getMinutes()) + ' min, ' + format2digits(d.getSeconds()) + ' sec';  };  var row;  while (row = getRow()) {    var game = row.value;    feed = game.feed,    events = [];        for (var i = 0; i < feed.length; ++i) {      var entry = feed[i];      entry.time = {        start: formatTime(game.start),        goal: formatTimespan(game.start, entry.time),        foul: formatTimespan(game.start, entry.time),        end: formatTime(game.end),        abort: formatTime(game.end)      }[entry.type];      events.push(entry);    }    data.feeds.push({events: events.reverse()});  }  return mustache.to_html(template, data);};",
       "live": "function(head, req) {  start({'headers': {'content-type': 'text/html'}});  var mustache = require('lib/mustache'),      template = this.templates['live.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    scoreboard: config.scoreboard,    players: []  };  for (var key in locales) {    data['locales.' + key] = locales[key];  }    var row;  while (row = getRow()) {    data.players.push(row.value);  }  data.players.sort(function(a, b) {    return (a.score > b.score) ? -1 : ((a.score < b.score) ? 1 : 0);  });  data.players.length > 10 && (data.players.length = 10);  var pos = 0,      prev;  for (var i = 0; i < data.players.length; ++i) {    var player = data.players[i];    ++pos;    if (player.score != prev) {      player.position = pos;    }    prev = player.score;  }  return mustache.to_html(template, data);};",
       "perfectGame": "function(head, req) {  start({'headers': {'content-type': 'text/html'}});    var mustache = require('lib/mustache'),      template = this.templates['perfectGames.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    games: []  };  var row;  while (row = getRow()) {    data.games.push(row.value);  }  return mustache.to_html(template,{data: JSON.stringify(data)});};",
       "table": "function(head, req) {  start({'headers': {'content-type': 'text/html'}});    var mustache = require('lib/mustache'),      template = this.templates['table.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    players: []  };  for (var key in locales) {    data['locales.' + key] = locales[key];  }  var row;  while (row = getRow()) {    data.players.push(row.value);  }  data.players.sort(function(a, b) {    return (a.score > b.score) ? -1 : ((a.score < b.score) ? 1 : 0);  });  var pos = 0,      prev;    for (var i = 0; i < data.players.length; ++i) {    var player = data.players[i];    ++pos;    if (player.score != prev) {     player.position = pos;    }    prev = player.score;    player.goals.diff = player.goals.scored - player.goals.conceded;  }  return mustache.to_html(template, data);};",
       "user": "function(head, req) {  start({'headers': {'content-type': 'text/html'}});  var mustache = require('lib/mustache'),      template = this.templates['user.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {};  for (var key in locales) {    data['locales.' + key] = locales[key];  }  var players = [];  var scores = [];  var row;  while (row = getRow()) {    var player = row.value;    if (!data.user && player.name === req.query['name']) {      data.user = player;    }    players.push(player);    scores.push(player.score);  }  players.sort(function(a, b) { return (a.score > b.score) ? -1 : ((a.score < b.score) ? 1 : 0); });  scores.sort(function(a, b) { return (a > b) ? -1 : ((a < b) ? 1 : 0); });  if (data.user) {    data.user.rank = scores.indexOf(data.user.score) + 1;    var opponents = [];    for (var name in data.user.opponents) {      var opponent = data.user.opponents[name];      opponent.name = name;      opponents.push(opponent);    }    opponents.sort(function(a, b) { return (a.lost > b.lost) ? -1 : ((a.lost < b.lost) ? 1 : 0); });    data.user.nemesis = opponents[0];    data.user.nemesis.quote = ~~(data.user.nemesis.lost / (data.user.nemesis.won + data.user.nemesis.lost) * 100);    var teammates = [];    for (var name in data.user.teammates) {      var teammate = data.user.teammates[name];      teammate.name = name;      teammates.push(teammate);    }    teammates.sort(function(a, b) { return (a.won > b.won) ? -1 : ((a.won < b.won) ? 1 : 0); });    data.user.buddy = teammates[0];    data.user.buddy && (data.user.buddy.quote = ~~(data.user.buddy.won / (data.user.buddy.won + data.user.buddy.lost) * 100));    var idx = players.indexOf(data.user);    data.user.challenger = (idx - 1 >= 0) ? players[idx - 1] : players[idx + 1];    data.user.challenger.rank = scores.indexOf(data.user.challenger.score) + 1;    var totalgames = data.user.games.won + data.user.games.lost;    data.user.games = {      won: {        amount: data.user.games.won,        percentage: ~~(data.user.games.won / totalgames * 100)      },      lost: {        amount: data.user.games.lost,        percentage: ~~(data.user.games.lost / totalgames * 100)      }    };    var totalgoals = data.user.goals.scored + data.user.goals.conceded;    data.user.goals = {      scored: {        amount: data.user.goals.scored,        percentage: ~~(data.user.goals.scored / totalgoals * 100)      },      conceded: {       amount: data.user.goals.conceded,       percentage: ~~(data.user.goals.conceded / totalgoals * 100)      }    };    var new_graph = [];    for (var i = 0; i < data.user.graph.length; ++i) {      var event = data.user.graph[i];      if (new_graph[i - 1]) {        var old_event = new_graph[new_graph.length - 1],            diff = Math.floor((event.time - old_event.time) / (1000 * 60 * 60 * 24));        for (;diff;--diff, new_graph.push(old_event));      }      new_graph.push(event);    }    var last_event = new_graph[new_graph.length -1];    var diff_today = Math.floor((new Date().getTime() - last_event.time) / (1000 * 60 * 60 * 24));    for (;diff_today;--diff_today, new_graph.push(last_event));    data.user.graph = new_graph.reduce(function(a, b) {      var abs = Math.abs(b.score);      a.high > abs || (a.high = abs);      a.ranks.push(b.score);      return a;    }, { high: 0, ranks: [] });    data.user.graph.high = Math.ceil(data.user.graph.high / 10) * 10;    data.user.graph.low = data.user.graph.high * -1;    var formatDate = function(time) {      var date = new Date(time),          day = date.getDate(),          month = date.getMonth() + 1;      return [day > 9 ? day : '0' + day, month > 9 ? month : '0' + month, date.getFullYear()].join('.');    };    data.user.registered = formatDate(data.user.registered);    data.user.history.map(function(game) {      game.end = formatDate(game.end);      game.players.home.length > 1 || game.players.home.push('');      game.players.visitors.length > 1 || game.players.visitors.push('');      game.score < 0 || (game.score = '+' + game.score);      return game;    });  } else {    data.user = {      name: req.query['name'],      score: 0,      rank: 'n/a',      games: {        won: {          amount: 0,          percentage: 0        },        lost: {          amount: 0,          percentage: 0        }      },      goals: {        scored: {          amount: 0,          percentage: 0        },        conceded: {          amount: 0,          percentage: 0        }      },      graph: {        high: 10,        low: -10,        ranks: []      },      registered: 'n/a'    };  }  return mustache.to_html(template, data);};"
   },
   "rewrites": [
       {
           "from": "/",
           "to": "/_show/index",
           "method": "GET"
       },
       {
           "from": "/live",
           "to": "/_list/live/players",
           "method": "GET"
       },
       {
           "from": "/feed",
           "to": "/_list/feed/ranked_games",
           "query": {
               "limit": "5",
               "descending": "true"
           }
       },
       {
           "from": "/table",
           "to": "/_list/table/players",
           "method": "GET"
       },
       {
           "from": "/statistic",
           "to": "/_show/statistic/statistic",
           "method": "GET"
       },
       {
           "from": "/perfectGames",
           "to": "/_list/perfectGames/perfect_games",
           "method": "GET"
       },
       {
           "from": "/statistic/:name",
           "to": "/_list/user/players",
           "method": "GET",
           "query": {
               "name": ":name"
           }
       },
       {
           "from": "/guide",
           "to": "/_show/guide",
           "method": "GET"
       },
       {
           "from": "/tos",
           "to": "/_show/tos",
           "method": "GET"
       },
       {
           "from": "/*",
           "to": "/*"
       }
   ],
   "shows": {
       "guide": "function(doc, req) {  var mustache = require('lib/mustache'),      template = this.templates['guide.html'],      config = this.config,      locales = this.resources['locales_' + config.locale],      data = [];  for (var key in locales) {    data['locales.' + key] = locales[key];  }  return {    body: mustache.to_html(template, data)  };};",
       "index": "function(doc, req) {  var mustache = require('lib/mustache'),      template = this.templates['index.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    production: config.env === 'production',    cdn: config.cdn,    rev: config.rev,    config: JSON.stringify(config)  };  for (var key in locales) {    data['locales.' + key] = locales[key];  }  return {    body: mustache.to_html(template, data)  };};",
       "statistic": "function(doc, req) {  start({'headers': {'content-type': 'text/html'}});  var mustache = require('lib/mustache'),      template = this.templates['statistic.html'],      config = this.config,      locales = this.resources['locales_' + config.locale];  var data = {    stats: doc  };  for (var key in locales) {    data['locales.' + key] = locales[key];  }  var formatDate = function(time) {    var date = new Date(time),        day = date.getDate(),        month = date.getMonth() + 1;    return [day > 9 ? day : '0' + day, month > 9 ? month : '0' + month, date.getFullYear()].join('.');  };  data.stats.started = formatDate(data.stats.started);  data.stats.avg = {    gamesPerDay: ~~(data.stats.total.games / data.stats.total.days),    durationPerGame: ~~(data.stats.total.duration / data.stats.total.games / 1000),    durationPerDay: ~~(data.stats.total.duration / data.stats.total.days / 1000 / 60)  };  data.stats.goals = {    home: {      amount: data.stats.goals.home,      percentage: ~~(data.stats.goals.home / data.stats.total.goals * 100)    },    visitors: {      amount: data.stats.goals.visitors,      percentage: ~~(data.stats.goals.visitors / data.stats.total.goals * 100)    }  };  data.stats.victories = {    home: {      amount: data.stats.victories.home,      percentage: ~~(data.stats.victories.home / data.stats.total.games * 100)    },    visitors: {      amount: data.stats.victories.visitors,      percentage: ~~(data.stats.victories.visitors / data.stats.total.games * 100)    }  };  data.stats.games.map(function(game) {    game.end = formatDate(game.end);    game.players.home.length > 1 || game.players.home.push('');    game.players.visitors.length > 1 || game.players.visitors.push('');  });  return {    body: mustache.to_html(template, data)  };};",
       "tos": "function(doc, req) {  var mustache = require('lib/mustache'),      template = this.templates['tos.html'],      config = this.config,      locales = this.resources['locales_' + config.locale],      data = [];  for (var key in locales) {    data['locales.' + key] = locales[key];  }  return {    body: mustache.to_html(template, data)  };};"
   },
   "views": {
       "by_rfid": {
           "map": "function(doc) {  if (doc.type === 'player') {emit(doc.rfid, {'id': doc._id,'name': doc.name,'rfid': doc.rfid});}}"
       },
       "perfect_games": {
           "map": "function(doc) {  if (doc.type === 'game' && doc.players.home.length && doc.players.visitors.length) {var score = doc.goals.reduce(function(prev, curr) {prev[curr.scorer]+=curr.value; return prev; }, {home: 0, visitors: 0});    if(score.home <= 0 || score.visitors <= 0) {                   emit(null, {'score': score, 'players': doc.players});    }    }}"
       },
       "players": {
           "map": "function(doc) {  if (doc.type === 'player') {    emit(doc._id, doc);  }}"
       },
       "ranked_games": {
           "map": "function(doc) {  if (doc.type === 'game' && doc.players.home.length && doc.players.visitors.length && doc.ranked) {    emit(doc.end, doc);  }}"
       },
       "unranked_games": {
           "map": "function(doc) {  if (doc.type === 'game' && doc.players.home.length && doc.players.visitors.length && !doc.ranked) {    emit(doc.end, doc);  }}"
       }
   },
   "validate_doc_updates": "function(newDoc, oldDoc, userCtx) {  log('OLD: ' + JSON.stringify(newDoc))  log('NEW: ' + JSON.stringify(oldDoc))  if (!~userCtx.roles.indexOf('_admin')) {    throw({unauthorized: 'You are not authorized to modify this document'});  }}"
}